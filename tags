!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/217cdf1/
->rl	landau/common-for-syntax.rkt	/^(define-for-syntax ->rl$/;"	f
Automatic differentiation	README.md	/^## Automatic differentiation$/;"	s	chapter:Description
BREAK	landau/runtime-defs.rkt	/^(define BREAK #f)$/;"	f
BUILT-IN-FUNCTIONS	landau/environment.rkt	/^  BUILT-IN-FUNCTIONS$/;"	f
Configuraiton	README.md	/^# Configuraiton$/;"	c
Description	README.md	/^# Description$/;"	c
Development in Landau	README.md	/^## Development in Landau$/;"	s	chapter:Description
Differentiation method	README.md	/^## Differentiation method$/;"	s	chapter:Description
Example	README.md	/^### Example$/;"	S	section:Description""Problem formulation
Example: Spacecraft movement	README.md	/^## Example: Spacecraft movement$/;"	s	chapter:Description
Examples	README.md	/^# Examples$/;"	c
Implementation	README.md	/^## Implementation$/;"	s	chapter:Description
Installation	README.md	/^# Installation$/;"	c
Jabcde_081551	tests/jup-sat.c	/^const long double Jabcde_081551[5] = { 99.36071400000000153e0, 175.89536899999998809e0, 300.3231/;"	v	typeref:typename:const long double[5]
Jabcde_T81552	tests/jup-sat.c	/^const long double Jabcde_T81552[5] = { 4850.4045999999998457e0, 1191.9604999999999109e0, 262.547/;"	v	typeref:typename:const long double[5]
Landau advantages	README.md	/^## Landau advantages$/;"	s	chapter:Description
Problem formulation	README.md	/^## Problem formulation$/;"	s	chapter:Description
Publications	README.md	/^## Publications$/;"	s	chapter:Description
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
TARGET	landau/target-config.rkt	/^  TARGET$/;"	f
_0.0	landau/metalang.rkt	/^(define-syntax (_0.0 stx)$/;"	f
_0.5	landau/metalang.rkt	/^(define-syntax (_0.5 stx)$/;"	f
_1.0	landau/metalang.rkt	/^(define-syntax (_1.0 stx)$/;"	f
_2.0	landau/metalang.rkt	/^(define-syntax (_2.0 stx)$/;"	f
_and	landau/metalang.rkt	/^(define-syntax (_and stx)$/;"	f
_begin	landau/metalang.rkt	/^(define-syntax (_begin stx)$/;"	f
_break	landau/metalang.rkt	/^(define-syntax (_break stx)$/;"	f
_cos	landau/metalang.rkt	/^(define-syntax (_cos stx)$/;"	f
_decl-real-func	landau/metalang.rkt	/^(define-syntax (_decl-real-func stx)$/;"	f
_define-var	landau/metalang.rkt	/^(define-syntax (_define-var stx)$/;"	f
_define-var-with-func-call	landau/metalang.rkt	/^(define-syntax (_define-var-with-func-call stx)$/;"	f
_empty-statement	landau/metalang.rkt	/^(define-syntax (_empty-statement stx)$/;"	f
_equal?	landau/metalang.rkt	/^(define-syntax (_equal? stx)$/;"	f
_exact->inexact	landau/metalang.rkt	/^(define-syntax (_exact->inexact stx)$/;"	f
_expt	landau/metalang.rkt	/^(define-syntax (_expt stx)$/;"	f
_for	landau/metalang.rkt	/^(define-syntax (_for stx)$/;"	f
_forever	landau/metalang.rkt	/^(define-syntax (_forever stx)$/;"	f
_func-call	landau/metalang.rkt	/^(define-syntax (_func-call stx)$/;"	f
_if	landau/metalang.rkt	/^(define-syntax (_if stx)$/;"	f
_if-stm	landau/metalang.rkt	/^(define-syntax (_if-stm stx)$/;"	f
_int*	landau/metalang.rkt	/^(define-syntax (_int* stx)$/;"	f
_int+	landau/metalang.rkt	/^(define-syntax (_int+ stx)$/;"	f
_int-	landau/metalang.rkt	/^(define-syntax (_int- stx)$/;"	f
_int-neg	landau/metalang.rkt	/^(define-syntax (_int-neg stx)$/;"	f
_int-vector-ref	landau/metalang.rkt	/^(define-syntax (_int-vector-ref stx)$/;"	f
_int/	landau/metalang.rkt	/^(define-syntax (_int\/ stx)$/;"	f
_int<	landau/metalang.rkt	/^(define-syntax (_int< stx)$/;"	f
_int<=	landau/metalang.rkt	/^(define-syntax (_int<= stx)$/;"	f
_int=	landau/metalang.rkt	/^(define-syntax (_int= stx)$/;"	f
_int>	landau/metalang.rkt	/^(define-syntax (_int> stx)$/;"	f
_int>=	landau/metalang.rkt	/^(define-syntax (_int>= stx)$/;"	f
_let	landau/metalang.rkt	/^(define-syntax (_let stx)$/;"	f
_let-int	landau/metalang.rkt	/^(define-syntax (_let-int stx)$/;"	f
_local	landau/metalang.rkt	/^(define-syntax (_local stx)$/;"	f
_not	landau/metalang.rkt	/^(define-syntax (_not stx)$/;"	f
_nothing	landau/metalang.rkt	/^(define-syntax (_nothing stx)$/;"	f
_or	landau/metalang.rkt	/^(define-syntax (_or stx)$/;"	f
_pure-func-call	landau/metalang.rkt	/^(define-syntax (_pure-func-call stx)$/;"	f
_rl*	landau/metalang.rkt	/^(define-syntax (_rl* stx)$/;"	f
_rl+	landau/metalang.rkt	/^(define-syntax (_rl+ stx)$/;"	f
_rl-	landau/metalang.rkt	/^(define-syntax (_rl- stx)$/;"	f
_rl-neg	landau/metalang.rkt	/^(define-syntax (_rl-neg stx)$/;"	f
_rl-vector	landau/metalang.rkt	/^(define-syntax (_rl-vector stx)$/;"	f
_rl/	landau/metalang.rkt	/^(define-syntax (_rl\/ stx)$/;"	f
_set!	landau/metalang.rkt	/^(define-syntax (_set! stx)$/;"	f
_sin	landau/metalang.rkt	/^(define-syntax (_sin stx)$/;"	f
_sqr	landau/metalang.rkt	/^(define-syntax (_sqr stx)$/;"	f
_sqrt	landau/metalang.rkt	/^(define-syntax (_sqrt stx)$/;"	f
_var-ref	landau/metalang.rkt	/^(define-syntax (_var-ref stx)$/;"	f
_vector-ref	landau/metalang.rkt	/^(define-syntax (_vector-ref stx)$/;"	f
_vector-set!	landau/metalang.rkt	/^(define-syntax (_vector-set! stx)$/;"	f
add-argument!	landau/environment.rkt	/^(define (add-argument! args name type)$/;"	f
add-lval-ders-to-rval!	landau/backrun.rkt	/^(define (add-lval-ders-to-rval! der-table available-dx-table discard-table l-val-ref r-val-ref)$/;"	f
add-real-var!	landau/environment.rkt	/^  (add-real-var! name type stx real-vars-table)$/;"	f
add-variable!	landau/environment.rkt	/^  (add-variable! vars name type)$/;"	f
al_index_name_symbol	landau/runtime-defs.rkt	/^(define al_index_name_symbol "al_index_name_symbol")$/;"	f
any-number?	landau/environment.rkt	/^(define (any-number? n)$/;"	f
argument/c	landau/environment.rkt	/^(define argument\/c (struct\/c argument symbol? type\/c))$/;"	f
assignation	landau/backrun.rkt	/^(define-syntax (assignation stx)$/;"	f
assignation	landau/semantics.rkt	/^(define-syntax (assignation stx)$/;"	f
atom-number	landau/common-for-syntax.rkt	/^(define-for-syntax (atom-number stx)$/;"	f
atom-number	landau/metalang.rkt	/^(define-for-syntax (atom-number stx)$/;"	f
backrun-ref/c	landau/environment.rkt	/^(define backrun-ref\/c (list\/c (or\/c 'array-ref 'func-ref) var-symbol\/c integer?))$/;"	f
base-type/c	landau/environment.rkt	/^(define base-type\/c (one-of\/c 'real 'int 'dual-l 'dual-r))$/;"	f
binary-op-cast	landau/backrun.rkt	/^(define-for-syntax (binary-op-cast op1 op2 stx)$/;"	f
binary-op-cast	landau/common-for-syntax.rkt	/^(define-for-syntax (binary-op-cast op1 op2 stx) (binary-op-cast-helper op1 op2 stx))$/;"	f
binary-op-cast	landau/semantics.rkt	/^(define-for-syntax (binary-op-cast expr1 expr2 stx) (binary-op-cast-helper expr1 expr2 stx))$/;"	f
binary-op-cast-helper	landau/common-for-syntax.rkt	/^(define-for-syntax (binary-op-cast-helper op1 op2 stx)$/;"	f
binding-type/c	landau/environment.rkt	/^(define binding-type\/c (or\/c 'constant 'parameter 'variable 'function))$/;"	f
bool-expr	landau/backrun.rkt	/^(define-syntax (bool-expr stx)$/;"	f
bool-expr	landau/semantics.rkt	/^(define-syntax (bool-expr stx)$/;"	f
bool-factor	landau/backrun.rkt	/^(define-syntax (bool-factor stx)$/;"	f
bool-factor	landau/semantics.rkt	/^(define-syntax (bool-factor stx)$/;"	f
bool-term	landau/backrun.rkt	/^(define-syntax (bool-term stx)$/;"	f
bool-term	landau/semantics.rkt	/^(define-syntax (bool-term stx)$/;"	f
c*	landau/combinators.rkt	/^(define (c* . x) (format "(~a)" (string-join (map (lambda (y) (format "~a" y)) x) " * ")))$/;"	f
c+	landau/combinators.rkt	/^(define (c+ . x) (format "(~a)" (string-join (map (lambda (y) (format "~a" y)) x) " + ")))$/;"	f
c-	landau/combinators.rkt	/^(define (c- x y) (format "(~a - ~a)" x y))$/;"	f
c-and	landau/combinators.rkt	/^(define (c-and x y) (format "(~a && ~a)" x y))$/;"	f
c-array-ref	landau/combinators.rkt	/^(define (c-array-ref name idx)$/;"	f
c-break	landau/combinators.rkt	/^(define (c-break)$/;"	f
c-cos	landau/combinators.rkt	/^(define (c-cos x) (format "cos(~a)" x))$/;"	f
c-cosl	landau/combinators.rkt	/^(define (c-cosl x) (format "cosl(~a)" x))$/;"	f
c-declare-array	landau/combinators.rkt	/^(define (c-declare-array type name size (modifier ""))$/;"	f
c-declare-var	landau/combinators.rkt	/^  (c-declare-var name-str type (modifier-pragma 'static) (value #f) (const? #f))$/;"	f
c-define	landau/combinators.rkt	/^(define (c-define type name value (modifier ""))$/;"	f
c-define-array	landau/combinators.rkt	/^(define (c-define-array type name size value (modifier ""))$/;"	f
c-exact->inexact	landau/combinators.rkt	/^(define (c-exact->inexact value)$/;"	f
c-for	landau/combinators.rkt	/^(define (c-for index start end body)$/;"	f
c-forever	landau/combinators.rkt	/^(define (c-forever index start body)$/;"	f
c-func-call	landau/combinators.rkt	/^(define (c-func-call func-name func-ret-symb args-list)$/;"	f
c-func-decl	landau/combinators.rkt	/^(define (c-func-decl return-type name return-value args body)$/;"	f
c-if	landau/combinators.rkt	/^(define (c-if pred true-body (false-body #f))$/;"	f
c-if-expr	landau/combinators.rkt	/^(define (c-if-expr pred true-body false-body)$/;"	f
c-ignore-void	landau/combinators.rkt	/^(define (c-ignore-void value)$/;"	f
c-indent	landau/combinators.rkt	/^(define (c-indent value)$/;"	f
c-line-end	landau/combinators.rkt	/^(define (c-line-end line)$/;"	f
c-make-array	landau/combinators.rkt	/^(define (c-make-array values-list)$/;"	f
c-neg	landau/combinators.rkt	/^(define (c-neg x) (format "-~a" x))$/;"	f
c-new-line	landau/combinators.rkt	/^(define (c-new-line line)$/;"	f
c-not	landau/combinators.rkt	/^(define (c-not x) (format "not~a" x))$/;"	f
c-or	landau/combinators.rkt	/^(define (c-or x y) (format "(~a || ~a)" x y))$/;"	f
c-pow	landau/combinators.rkt	/^(define (c-pow x y) (format "pow(~a, ~a)" x y))$/;"	f
c-powl	landau/combinators.rkt	/^(define (c-powl x y) (format "powl(~a, ~a)" x y))$/;"	f
c-pure-func-call	landau/combinators.rkt	/^(define (c-pure-func-call func-name args-list)$/;"	f
c-return	landau/combinators.rkt	/^(define (c-return value)$/;"	f
c-set	landau/combinators.rkt	/^(define (c-set symb value)$/;"	f
c-set-array	landau/combinators.rkt	/^(define (c-set-array symb idx value)$/;"	f
c-sin	landau/combinators.rkt	/^(define (c-sin x) (format "sin(~a)" x))$/;"	f
c-sinl	landau/combinators.rkt	/^(define (c-sinl x) (format "sinl(~a)" x))$/;"	f
c-sqrt	landau/combinators.rkt	/^(define (c-sqrt x) (format "sqrt(~a)" x))$/;"	f
c-sqrtl	landau/combinators.rkt	/^(define (c-sqrtl x) (format "sqrtl(~a)" x))$/;"	f
c-with-brackets	landau/combinators.rkt	/^(define (c-with-brackets body)$/;"	f
c/	landau/combinators.rkt	/^(define (c\/ x y) (format "(~a \/ ~a)" x y))$/;"	f
c<	landau/combinators.rkt	/^(define (c< x y) (format "(~a < ~a)" x y))$/;"	f
c<=	landau/combinators.rkt	/^(define (c<= x y) (format "(~a <= ~a)" x y))$/;"	f
c==	landau/combinators.rkt	/^(define (c== x y) (format "(~a == ~a)" x y))$/;"	f
c>	landau/combinators.rkt	/^(define (c> x y) (format "(~a > ~a)" x y))$/;"	f
c>=	landau/combinators.rkt	/^(define (c>= x y) (format "(~a >= ~a)" x y))$/;"	f
cast-func-args-list	landau/semantics.rkt	/^(define-for-syntax (cast-func-args-list func-args-list)$/;"	f
central_grav81553	tests/jup-sat.c	/^const long double central_grav81553[7] = { 0.0e0, 0.0e0, -0.0065724808672554692115e0, 0.0e0, 0.0/;"	v	typeref:typename:const long double[7]
change-arg-type!	landau/environment.rkt	/^(define (change-arg-type! args name new-type)$/;"	f
check-duplicate-argument-name	landau/backrun.rkt	/^(define-for-syntax (check-duplicate-argument-name args funcname name stx-name)$/;"	f
check-duplicate-constant	landau/backrun.rkt	/^(define-for-syntax (check-duplicate-constant name stx)$/;"	f
check-duplicate-constant	landau/semantics.rkt	/^(define-for-syntax (check-duplicate-constant name stx)$/;"	f
check-duplicate-parameter	landau/backrun.rkt	/^(define-for-syntax (check-duplicate-parameter name stx)$/;"	f
check-duplicate-parameter	landau/semantics.rkt	/^(define-for-syntax (check-duplicate-parameter name stx)$/;"	f
check-duplicate-variable-name	landau/backrun.rkt	/^(define-for-syntax (check-duplicate-variable-name name stx-name)$/;"	f
check-duplicate-variable-name	landau/semantics.rkt	/^(define-for-syntax (check-duplicate-variable-name name stx-name)$/;"	f
check-proper-getter	landau/backrun.rkt	/^(define-for-syntax (check-proper-getter idx-stx slice-colon expanded-range expanded-idx name-str/;"	f
check-real-arg-or-parameter-existence	landau/backrun.rkt	/^(define-for-syntax (check-real-arg-or-parameter-existence name [get-range #f])$/;"	f
check-real-func-existence	landau/backrun.rkt	/^(define-for-syntax (check-real-func-existence name [get-range #f])$/;"	f
check-real-var-existence	landau/backrun.rkt	/^(define-for-syntax (check-real-var-existence name [get-range #f])$/;"	f
check-result	landau/common-for-syntax.rkt	/^(define-for-syntax (check-result stx err-str func-res)$/;"	f
coerce-to-fixnum	landau/backrun.rkt	/^(define-for-syntax (coerce-to-fixnum x)$/;"	f
coerce-to-list	landau/backrun.rkt	/^(define (coerce-to-list any)$/;"	f
constant	landau/backrun.rkt	/^(define-syntax (constant stx)$/;"	f
constant	landau/semantics.rkt	/^(define-syntax (constant stx)$/;"	f
constants	landau/environment.rkt	/^(define constants (make-hash))$/;"	f
current-arguments	landau/backrun.rkt	/^(define-syntax-parameter current-arguments #f)$/;"	f
current-arguments/c	landau/environment.rkt	/^(define current-arguments\/c (hash\/c symbol? argument\/c))$/;"	f
current-variables	landau/backrun.rkt	/^(define-syntax-parameter current-variables #f)$/;"	f
current-variables/c	landau/environment.rkt	/^(define current-variables\/c$/;"	f
debug	landau/common-for-syntax.rkt	/^(define-for-syntax debug #f)$/;"	f
debug-backrun	landau/backrun.rkt	/^(define debug-backrun #t)$/;"	f
debug-compile	landau/semantics.rkt	/^(define-for-syntax debug-compile #f)$/;"	f
debug-runtime	landau/runtime-defs.rkt	/^(define debug-runtime #f)$/;"	f
der-annot	landau/backrun.rkt	/^(define-syntax (der-annot stx)$/;"	f
der-annot	landau/semantics.rkt	/^(define-syntax (der-annot stx)$/;"	f
der-apply	landau/backrun.rkt	/^(define-syntax (der-apply stx)$/;"	f
der-apply	landau/semantics.rkt	/^(define-syntax (der-apply stx)$/;"	f
df-der-table/c	landau/environment.rkt	/^(define df-der-table\/c (hash\/c dx-name\/c (list\/c (symbols 'dx-idxs) mutable-set\/c)))$/;"	f
df-name/c	landau/environment.rkt	/^(define df-name\/c (list\/c var-symbol\/c integer?))$/;"	f
df-slice-idx-name-GLOBAL	landau/backrun.rkt	/^(define-for-syntax df-slice-idx-name-GLOBAL 'df_slice_idx)$/;"	f
df-slice-idx-name-GLOBAL	landau/semantics.rkt	/^(define-for-syntax df-slice-idx-name-GLOBAL 'df_slice_idx)$/;"	f
df_slice_idx	landau/backrun.rkt	/^(define df_slice_idx #f)$/;"	f
df_slice_idx	landau/runtime-defs.rkt	/^(define df_slice_idx 'bad_runtime_df_slice_idx)$/;"	f
discard	landau/backrun.rkt	/^(define-syntax (discard stx)$/;"	f
discard	landau/semantics.rkt	/^(define-syntax (discard stx)$/;"	f
dx-name-in-current-al	landau/semantics.rkt	/^(define-syntax-parameter dx-name-in-current-al #f)$/;"	f
dx-name/c	landau/environment.rkt	/^(define dx-name\/c string?)$/;"	f
dx-names-hash-set/c	landau/environment.rkt	/^(define dx-names-hash-set\/c (hash\/c string? boolean?))$/;"	f
dx-names-set	landau/backrun.rkt	/^(define-syntax-parameter dx-names-set #f)$/;"	f
dx-names-set/c	landau/environment.rkt	/^(define dx-names-set\/c (hash\/c string? boolean?))$/;"	f
dx-slice-idx-name-GLOBAL	landau/backrun.rkt	/^(define-for-syntax dx-slice-idx-name-GLOBAL 'dx_slice_idx)$/;"	f
dx-slice-idx-name-GLOBAL	landau/semantics.rkt	/^(define-for-syntax dx-slice-idx-name-GLOBAL 'dx_slice_idx)$/;"	f
dx_slice_idx	landau/backrun.rkt	/^(define dx_slice_idx #f)$/;"	f
dx_slice_idx	landau/runtime-defs.rkt	/^(define dx_slice_idx 'bad_runtime_dx_slice_idx)$/;"	f
elem	landau/lang/reader.rkt	/^(define (elem v lst)$/;"	f
element	landau/backrun.rkt	/^(define-syntax (element stx)$/;"	f
element	landau/semantics.rkt	/^(define-syntax (element stx)$/;"	f
expand-range	landau/backrun.rkt	/^(define-for-syntax (expand-range rng-stx rng)$/;"	f
expand-type	landau/type-utils.rkt	/^(define-for-syntax (expand-type type-stx)$/;"	f
expand-value-only	landau/semantics.rkt	/^(define-syntax-parameter expand-value-only #f)$/;"	f
expr	landau/backrun.rkt	/^(define-syntax (expr stx)$/;"	f
expr	landau/semantics.rkt	/^(define-syntax (expr stx)$/;"	f
expr-body	landau/backrun.rkt	/^(define-syntax (expr-body stx)$/;"	f
expr-body	landau/semantics.rkt	/^(define-syntax (expr-body stx)$/;"	f
extract	landau/common-for-syntax.rkt	/^(define-for-syntax (extract stx)$/;"	f
f	tests/test.c	/^int f(long double *restrict f8968, long double *restrict m8969) {$/;"	f	typeref:typename:int
factor	landau/backrun.rkt	/^(define-syntax (factor stx)$/;"	f
factor	landau/semantics.rkt	/^(define-syntax (factor stx)$/;"	f
fmap	landau/common-for-syntax.rkt	/^(define-for-syntax (fmap f maybe-false)$/;"	f
for-expr	landau/backrun.rkt	/^(define-syntax (for-expr stx)$/;"	f
for-expr	landau/semantics.rkt	/^(define-syntax (for-expr stx)$/;"	f
func	landau/backrun.rkt	/^(define-syntax (func stx)$/;"	f
func	landau/semantics.rkt	/^(define-syntax (func stx)$/;"	f
func-body	landau/backrun.rkt	/^(define-syntax (func-body stx)$/;"	f
func-body	landau/semantics.rkt	/^(define-syntax (func-body stx)$/;"	f
func-call	landau/backrun.rkt	/^(define-syntax (func-call stx)$/;"	f
func-call	landau/semantics.rkt	/^(define-syntax (func-call stx)$/;"	f
func-call-ht	landau/semantics.rkt	/^(define-syntax-parameter func-call-ht 'func-call-ht-not-set)$/;"	f
func-call-ht/c	landau/environment.rkt	/^(define func-call-ht\/c (hash\/c symbol? func-call-info\/c))$/;"	f
func-call-info/c	landau/environment.rkt	/^(define func-call-info\/c$/;"	f
func-context	landau/semantics.rkt	/^(define-syntax-parameter func-context #f)$/;"	f
func-context/c	landau/environment.rkt	/^(define func-context\/c$/;"	f
func-info/c	landau/environment.rkt	/^(define func-info\/c $/;"	f
func-slice-idx-name-GLOBAL	landau/backrun.rkt	/^(define-for-syntax func-slice-idx-name-GLOBAL 'func_slice_idx)$/;"	f
func-slice-idx-name-GLOBAL	landau/semantics.rkt	/^(define-for-syntax func-slice-idx-name-GLOBAL 'func_slice_idx)$/;"	f
func_slice_idx	landau/backrun.rkt	/^(define func_slice_idx #f)$/;"	f
func_slice_idx	landau/runtime-defs.rkt	/^(define func_slice_idx 'bad_runtime_func_slice_idx)$/;"	f
funcs-info-GLOBAL	landau/backrun.rkt	/^(define-for-syntax funcs-info-GLOBAL (make-hash))$/;"	f
funcs-info-GLOBAL	landau/semantics.rkt	/^(define-for-syntax funcs-info-GLOBAL #f)$/;"	f
funcs-info/c	landau/environment.rkt	/^(define funcs-info\/c (hash\/c var-symbol\/c func-info\/c))$/;"	f
function-name	landau/backrun.rkt	/^(define-syntax-parameter function-name #f)$/;"	f
function-return-type	landau/backrun.rkt	/^(define-syntax-parameter function-return-type  #f)$/;"	f
function-return-value	landau/backrun.rkt	/^(define-syntax-parameter function-return-value #f)$/;"	f
functions-data-ht-GLOBAL	landau/semantics.rkt	/^(define-for-syntax functions-data-ht-GLOBAL #f)$/;"	f
functions-symbols/c	landau/environment.rkt	/^(define functions-symbols\/c (hash\/c string? symbol?))$/;"	f
fxvec->vec	landau/common-for-syntax.rkt	/^(define (fxvec->vec fxvec)$/;"	f
fxvec->vec	landau/common-for-syntax.rkt	/^(define-for-syntax (fxvec->vec fxvec)$/;"	f
fxvector->vector	landau/common-for-syntax.rkt	/^(define-for-syntax (fxvector->vector fxvec)$/;"	f
g	tests/test.c	/^int g(long double g8974) {$/;"	f	typeref:typename:int
get-arg-type	landau/semantics.rkt	/^(define-for-syntax (get-arg-type d-name)$/;"	f
get-arg-type-helper	landau/common-for-syntax.rkt	/^(define-for-syntax (get-arg-type-helper d-name current-arguments)$/;"	f
get-array-type	landau/common-for-syntax.rkt	/^(define-for-syntax (get-array-type type)$/;"	f
get-derivative	landau/backrun.rkt	/^(define-syntax (get-derivative stx)$/;"	f
get-derivative	landau/semantics.rkt	/^(define-syntax (get-derivative stx)$/;"	f
get-derivative-stx	landau/common-for-syntax.rkt	/^(define-for-syntax (get-derivative-stx dual-b-expanded-stx)$/;"	f
get-expanded-slice-index-end	landau/backrun.rkt	/^(define-for-syntax (get-expanded-slice-index-end stx index-end array-range-stx)$/;"	f
get-expanded-slice-index-start	landau/backrun.rkt	/^(define-for-syntax (get-expanded-slice-index-start index-start)$/;"	f
get-name-mode	landau/semantics.rkt	/^(define-syntax-parameter get-name-mode #f)$/;"	f
get-real-arg-or-parameter-type	landau/semantics.rkt	/^(define-for-syntax (get-real-arg-or-parameter-type name)$/;"	f
get-real-arg-or-var-type	landau/semantics.rkt	/^(define-for-syntax (get-real-arg-or-var-type d-name)$/;"	f
get-slice-range	landau/common-for-syntax.rkt	/^(define-for-syntax (get-slice-range type)$/;"	f
get-slice-start-and-range	landau/common-for-syntax.rkt	/^(define-for-syntax (get-slice-start-and-range stx slice-colon index-start index-end array-range)$/;"	f
get-slice-type	landau/common-for-syntax.rkt	/^(define-for-syntax (get-slice-type type)$/;"	f
get-source-name	landau/target-config.rkt	/^(define (get-source-name)$/;"	f
get-value	landau/backrun.rkt	/^(define-syntax (get-value stx)$/;"	f
get-value	landau/semantics.rkt	/^(define-syntax (get-value stx)$/;"	f
get-value-stx	landau/common-for-syntax.rkt	/^(define-for-syntax (get-value-stx dual-b-expanded-stx)$/;"	f
get_dfdx_cell	tests/jup-sat.c	/^static inline long double get_dfdx_cell(int full_idx81535, int dx_mapped_size81536, int al_idx81/;"	f	typeref:typename:long double	file:
get_dfdx_cell	tests/test.c	/^static inline long double get_dfdx_cell(int full_idx8957, int dx_mapped_size8958, int al_idx8959/;"	f	typeref:typename:long double	file:
get_dfdx_cell_dx	tests/jup-sat.c	/^static inline long double get_dfdx_cell_dx(int full_idx81535, int dx_mapped_size81536, int al_id/;"	f	typeref:typename:long double	file:
get_dfdx_cell_dx	tests/test.c	/^static inline long double get_dfdx_cell_dx(int full_idx8957, int dx_mapped_size8958, int al_idx8/;"	f	typeref:typename:long double	file:
get_dfdx_var	tests/jup-sat.c	/^static inline long double get_dfdx_var(int al_idx81542, int inv_mapping_period81543, int *restri/;"	f	typeref:typename:long double	file:
get_dfdx_var	tests/test.c	/^static inline long double get_dfdx_var(int al_idx8964, int inv_mapping_period8965, int *restrict/;"	f	typeref:typename:long double	file:
grouped-keys-table/c	landau/environment.rkt	/^(define grouped-keys-table\/c (hash\/c var-symbol\/c (listof integer?)))$/;"	f
has-dual	landau/common-for-syntax.rkt	/^(define-for-syntax (has-dual stx)$/;"	f
hash->string	landau/environment.rkt	/^(define (hash->string ht)$/;"	f
if-expr	landau/backrun.rkt	/^(define-syntax (if-expr stx)$/;"	f
if-expr	landau/semantics.rkt	/^(define-syntax (if-expr stx)$/;"	f
indent-step	landau/combinators.rkt	/^(define indent-step 2)$/;"	f
init-state	tests/test_spacecraft.rkt	/^(define (init-state pos vel)$/;"	f
instantiate	landau/type-utils.rkt	/^(define-for-syntax (instantiate type-stx)$/;"	f
instantiate-dual-var	landau/common-for-syntax.rkt	/^(define-for-syntax (instantiate-dual-var df-type dx-mapped-size stx)$/;"	f
is-array-ref?	landau/common-for-syntax.rkt	/^(define (is-array-ref? ref) (equal? (car ref) 'array-ref))$/;"	f
is-array-type?	landau/common-for-syntax.rkt	/^(define-for-syntax (is-array-type? type)$/;"	f
is-basic-ref?	landau/common-for-syntax.rkt	/^(define (is-basic-ref? ref) (equal? (car ref) 'basic-ref))$/;"	f
is-dual	landau/common-for-syntax.rkt	/^(define-for-syntax (is-dual stx)$/;"	f
is-func?	landau/backrun.rkt	/^(define-for-syntax (is-func? stx)$/;"	f
is-int	landau/common-for-syntax.rkt	/^(define-for-syntax (is-int stx)$/;"	f
is-int-index	landau/backrun.rkt	/^(define-for-syntax (is-int-index stx)$/;"	f
is-real	landau/common-for-syntax.rkt	/^(define-for-syntax (is-real stx)$/;"	f
is-slice-of-type	landau/common-for-syntax.rkt	/^(define-for-syntax (is-slice-of-type basic-type type)$/;"	f
is-slice?	landau/common-for-syntax.rkt	/^(define-for-syntax (is-slice? type)$/;"	f
is-type	landau/common-for-syntax.rkt	/^(define-for-syntax (is-type stx type)$/;"	f
is-type_	landau/common-for-syntax.rkt	/^(define-for-syntax (is-type_ type stx)$/;"	f
jupiter-grav	tests/test-zonal-grav.rkt	/^(define jupiter-grav$/;"	f
jupiter_rotation_matrix	tests/jup-sat.c	/^int jupiter_rotation_matrix(long double *restrict jupiter_rotation_matrix81554, long double t815/;"	f	typeref:typename:int
jupsatsystem	tests/jup-sat.c	/^int jupsatsystem(long double *restrict jupsatsystem81618, long double t81619, long double *restr/;"	f	typeref:typename:int
jupsatsystem_noderiv	tests/jup-sat.c	/^int jupsatsystem_noderiv(long double *restrict jupsatsystem_noderiv82027, long double t82028, lo/;"	f	typeref:typename:int
landau-type	landau/common-for-syntax.rkt	/^(define-for-syntax (landau-type base-type (slice-range #f))$/;"	f
landau-type/c	landau/environment.rkt	/^(define landau-type\/c (list\/c base-type\/c (or\/c (list\/c integer?) (list\/c))))$/;"	f
lang/c	landau/target-config.rkt	/^(define lang\/c (one-of\/c 'racket 'ansi-c))$/;"	f
lex:letter	landau/lexer.rkt	/^  (lex:letter (:or (:\/ #\\a #\\z) (:\/ #\\A #\\Z) #\\_))$/;"	f
lexer-src-pos-with-tokens	landau/lexer.rkt	/^(define-syntax (lexer-src-pos-with-tokens stx)$/;"	f
list->rl-vector	landau/common-for-syntax.rkt	/^(define-for-syntax (list->rl-vector value-list)$/;"	f
log-debug	landau/backrun.rkt	/^(define (log-debug msg)$/;"	f
log-debug	landau/runtime-defs.rkt	/^(define (log-debug msg)$/;"	f
log-debug	landau/semantics.rkt	/^(define-for-syntax (log-debug msg [force-log #f])$/;"	f
loop	landau/runtime-defs.rkt	/^(define (loop i end body)$/;"	f
loop-forever	landau/runtime-defs.rkt	/^(define (loop-forever i body)$/;"	f
make-der-decl-list!	landau/semantics.rkt	/^(define-for-syntax (make-der-decl-list! args stx)$/;"	f
make-derivative-getter-func	landau/semantics.rkt	/^(define-for-syntax (make-derivative-getter-func stx)$/;"	f
make-derivative-getter-func/array	landau/semantics.rkt	/^(define-for-syntax (make-derivative-getter-func\/array stx)$/;"	f
make-dual-type	landau/common-for-syntax.rkt	/^(define-for-syntax (make-dual-type parsed-type dual-type)$/;"	f
make-dx-idxs-mappings-name	landau/environment.rkt	/^  (make-dx-idxs-mappings-name var-symb dx-name-str)$/;"	f
make-landau-type	landau/environment.rkt	/^  (make-landau-type base-type size)$/;"	f
make-mappings-decl-list!	landau/semantics.rkt	/^(define-for-syntax (make-mappings-decl-list! dx-name-str grouped-keys-table stx)$/;"	f
make-set-all-derivatives-to-zero/array	landau/semantics.rkt	/^    (make-set-all-derivatives-to-zero\/array$/;"	f
make-var-der-name	landau/environment.rkt	/^  (make-var-der-name var-der-symb dx-name-str)$/;"	f
make-var-mappings-name	landau/environment.rkt	/^  (make-var-mappings-name var-symb dx-name-str)$/;"	f
mapped_idx	landau/runtime-defs.rkt	/^(define mapped_idx 'mapped_idx_not_set)$/;"	f
mapping-sizes/c	landau/environment.rkt	/^(define mapping-sizes\/c (struct\/c mapping-sizes integer? integer?))$/;"	f
mappings_full_idx_symbol	landau/runtime-defs.rkt	/^(define mappings_full_idx_symbol 'mappings_full_idx_not_set)$/;"	f
mutable-set/c	landau/environment.rkt	/^(define (mutable-set\/c a) any\/c)$/;"	f
my-read	landau/lang/reader.rkt	/^(define (my-read in)$/;"	f
my-read-syntax	landau/lang/reader.rkt	/^(define (my-read-syntax src ip)$/;"	f
need-derivatives?	landau/semantics.rkt	/^(define-for-syntax (need-derivatives? name-str)$/;"	f
need-only-value-set/c	landau/environment.rkt	/^(define need-only-value-set\/c (mutable-set\/c var-symbol\/c))$/;"	f
new-variables-nesting	landau/environment.rkt	/^(define (new-variables-nesting vars)$/;"	f
normilize-rl	landau/common-for-syntax.rkt	/^(define-for-syntax (normilize-rl rl)$/;"	f
not-void?	landau/common-for-syntax.rkt	/^(define-for-syntax (not-void? it) (not (equal? (void) it)))$/;"	f
not-void?	landau/runtime-defs.rkt	/^(define (not-void? it) (not (equal? (void) it)))$/;"	f
number	landau/backrun.rkt	/^(define-syntax (number stx)$/;"	f
number	landau/semantics.rkt	/^(define-syntax (number stx)$/;"	f
nut_prec_dec81550	tests/jup-sat.c	/^const long double nut_prec_dec81550[5] = { 5.0000000000000002396e-05, 0.00040400000000000000798e/;"	v	typeref:typename:const long double[5]
nut_prec_ra81549	tests/jup-sat.c	/^const long double nut_prec_ra81549[5] = { 0.00011699999999999999788e0, 0.00093800000000000003167/;"	v	typeref:typename:const long double[5]
offset	landau/combinators.rkt	/^(define offset (make-parameter 0))$/;"	f
offset-string	landau/combinators.rkt	/^(define (offset-string level) (make-string (fx* level indent-step) #\\ ))$/;"	f
output_directory	config.json	/^    "output_directory": ".\/"$/;"	s
override-with-command-line	landau/target-config.rkt	/^(define\/contract (override-with-command-line cfg-target)$/;"	f
parameter	landau/backrun.rkt	/^(define-syntax (parameter stx)$/;"	f
parameter	landau/semantics.rkt	/^(define-syntax (parameter stx)$/;"	f
parameters	landau/environment.rkt	/^(define parameters (make-hash))$/;"	f
parse-target-cfg	landau/target-config.rkt	/^(define (parse-target-cfg inp-path)$/;"	f
parse-type	landau/environment.rkt	/^(define (parse-type t)$/;"	f
parse-type-to-syntax	landau/environment.rkt	/^(define (parse-type-to-syntax t)$/;"	f
path-only_	landau/target-config.rkt	/^(define (path-only_ path)$/;"	f
pm81548	tests/jup-sat.c	/^const long double pm81548[2] = { 284.94999999999998863e0, 870.5359999999999445e0 };$/;"	v	typeref:typename:const long double[2]
pole_dec81547	tests/jup-sat.c	/^const long double pole_dec81547[2] = { 64.49530300000000693e0, 0.0024130000000000002142e0 };$/;"	v	typeref:typename:const long double[2]
pole_ra81546	tests/jup-sat.c	/^const long double pole_ra81546[2] = { 268.05659500000001572e0, -0.006498999999999999569e0 };$/;"	v	typeref:typename:const long double[2]
prepand-headers	landau/combinators.rkt	/^(define (prepand-headers src-str)$/;"	f
primary	landau/backrun.rkt	/^(define-syntax (primary stx)$/;"	f
primary	landau/semantics.rkt	/^(define-syntax (primary stx)$/;"	f
print	landau/backrun.rkt	/^(define-syntax (print stx)$/;"	f
print	landau/semantics.rkt	/^(define-syntax (print stx)$/;"	f
process	landau/backrun.rkt	/^  (process actions-list dx-names-set real-vars-table)$/;"	f
program	landau/backrun.rkt	/^(define-syntax (program stx)$/;"	f
program	landau/semantics.rkt	/^(define-syntax (program stx)$/;"	f
prohibition-list/c	landau/environment.rkt	/^(define prohibition-list\/c (listof binding-type\/c))$/;"	f
range-casting-check	landau/backrun.rkt	/^(define-for-syntax (range-casting-check stx r-value-type lvalue-outer-prod-range)$/;"	f
range-check	landau/backrun.rkt	/^(define-for-syntax (range-check stx idx range)$/;"	f
range-check-stx	landau/backrun.rkt	/^(define-for-syntax (range-check-stx stx idx range)$/;"	f
real-vars-table	landau/backrun.rkt	/^(define-syntax-parameter real-vars-table #f)$/;"	f
ref-to-key	landau/environment.rkt	/^  (ref-to-key ref)$/;"	f
resolve-path	landau/target-config.rkt	/^(define (resolve-path relative-path)$/;"	f
rl*	landau/common-for-syntax.rkt	/^(define-for-syntax rl*$/;"	f
rl+	landau/common-for-syntax.rkt	/^(define-for-syntax rl+$/;"	f
rl-	landau/common-for-syntax.rkt	/^(define-for-syntax rl-$/;"	f
rl-cos	landau/common-for-syntax.rkt	/^(define-for-syntax rl-cos$/;"	f
rl-expt	landau/common-for-syntax.rkt	/^(define-for-syntax rl-expt$/;"	f
rl-neg	landau/common-for-syntax.rkt	/^(define-for-syntax (rl-neg n)$/;"	f
rl-sin	landau/common-for-syntax.rkt	/^(define-for-syntax rl-sin$/;"	f
rl-sqr	landau/common-for-syntax.rkt	/^(define-for-syntax (rl-sqr x)$/;"	f
rl-sqrt	landau/common-for-syntax.rkt	/^(define-for-syntax rl-sqrt$/;"	f
rl-vector-ref	landau/common-for-syntax.rkt	/^(define-for-syntax rl-vector-ref$/;"	f
rl/	landau/common-for-syntax.rkt	/^(define-for-syntax rl\/$/;"	f
runge-kutta-4	tests/test_spacecraft.rkt	/^(define (runge-kutta-4 x0 get-deriv delta)$/;"	f
s:l	Session.vim	/^let s:l = 1002 - ((27 * winheight(0) + 28) \/ 56)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
search-argument	landau/environment.rkt	/^(define (search-argument name args)$/;"	f
search-variable	landau/environment.rkt	/^(define (search-variable name vars)$/;"	f
set-need-only-value-set!	landau/common-for-syntax.rkt	/^(define-for-syntax (set-need-only-value-set! grouped-keys-table der-table need-only-value-set)$/;"	f
single-term	landau/backrun.rkt	/^(define-syntax (single-term stx)$/;"	f
single-term	landau/semantics.rkt	/^(define-syntax (single-term stx)$/;"	f
slice-helper	landau/backrun.rkt	/^(define-for-syntax (slice-helper stx dx-index-start dx-index-end expanded-range-dx)$/;"	f
slice-idx-name-GLOBAL	landau/backrun.rkt	/^(define-for-syntax slice-idx-name-GLOBAL 'slice_idx)$/;"	f
slice-idx-name-GLOBAL	landau/semantics.rkt	/^(define-for-syntax slice-idx-name-GLOBAL 'slice_idx)$/;"	f
slice_idx	landau/backrun.rkt	/^(define slice_idx #f)$/;"	f
slice_idx	landau/runtime-defs.rkt	/^(define slice_idx 'bad-runtime)$/;"	f
splice-nested	landau/backrun.rkt	/^(define (splice-nested lst)$/;"	f
syntax->string	landau/environment.rkt	/^(define (syntax->string stx)$/;"	f
syntax->string	landau/metalang.rkt	/^(define-for-syntax (syntax->string stx)$/;"	f
target/c	landau/target-config.rkt	/^(define target\/c (struct\/c target $/;"	f
target_language	config.json	/^    "target_language": "ansi-c",$/;"	s
term	landau/backrun.rkt	/^(define-syntax (term stx)$/;"	f
term	landau/semantics.rkt	/^(define-syntax (term stx)$/;"	f
throw-if-bundle-mistype	landau/backrun.rkt	/^(define (throw-if-bundle-mistype bundl-1 bundl-2)$/;"	f
throw-if-not-int	landau/environment.rkt	/^(define (throw-if-not-int stx [annotation ""])$/;"	f
throw-if-not-type	landau/environment.rkt	/^(define (throw-if-not-type expected-type stx [annotation ""])$/;"	f
throw-if-r-value-is-slice	landau/backrun.rkt	/^(define-for-syntax (throw-if-r-value-is-slice stx r-value-stx)$/;"	f
to-c-decl	landau/combinators.rkt	/^(define (to-c-decl landau-parsed-type name-str [value #'#f])$/;"	f
to-c-der-decl	landau/combinators.rkt	/^(define (to-c-der-decl df-type dx-size name-str)  $/;"	f
to-c-func-param	landau/combinators.rkt	/^(define (to-c-func-param landau-parsed-type name-str target)$/;"	f
to-string	landau/combinators.rkt	/^(define (to-string x)$/;"	f
tokenize	landau/lexer.rkt	/^(define (tokenize ip)$/;"	f
type-base	landau/type-utils.rkt	/^(define-for-syntax (type-base type-stx)$/;"	f
type-range	landau/type-utils.rkt	/^(define-for-syntax (type-range type-stx)$/;"	f
type/c	landau/environment.rkt	/^(define type\/c any\/c)$/;"	f
typecheck-mode	landau/semantics.rkt	/^(define-syntax-parameter typecheck-mode #f)$/;"	f
use_extfloat	config.json	/^    "use_extfloat": true,$/;"	b
var-decl	landau/backrun.rkt	/^(define-syntax (var-decl stx)$/;"	f
var-decl	landau/semantics.rkt	/^(define-syntax (var-decl stx)$/;"	f
var-symbol->string	landau/environment.rkt	/^  (var-symbol->string vs)$/;"	f
var-symbol/c	landau/environment.rkt	/^(define var-symbol\/c$/;"	f
variable/c	landau/environment.rkt	/^(define variable\/c (struct\/c variable $/;"	f
vec->fxvec	landau/common-for-syntax.rkt	/^(define (vec->fxvec vec)$/;"	f
vec->fxvec	landau/common-for-syntax.rkt	/^(define-for-syntax (vec->fxvec vec)$/;"	f
vector->carray	landau/common-for-syntax.rkt	/^(define-for-syntax (vector->carray vec)$/;"	f
with-syntax-property	landau/common-for-syntax.rkt	/^(define-for-syntax (with-syntax-property property-name property-value stx)$/;"	f
write-source	landau/semantics.rkt	/^(define-for-syntax (write-source stx src-synt)$/;"	f
xor	landau/common-for-syntax.rkt	/^(define-for-syntax (xor e1 e2)$/;"	f
