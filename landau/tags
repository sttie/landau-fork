!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
"d~ad~a_der"	environment.rkt	/^(define\/contract$/;"	f
"d~ad~a_mpg"	environment.rkt	/^(define\/contract$/;"	f
#f	environment.rkt	/^(define\/contract$/;"	f
#f	semantics.rkt	/^(define\/contract$/;"	f
'real	environment.rkt	/^(define\/contract$/;"	f
->rl	common-for-syntax.rkt	/^(define-for-syntax ->rl$/;"	f
<math.h>\n\n~a"	combinators.rkt	/^(define\/contract$/;"	f
BREAK	runtime-defs.rkt	/^(define BREAK #f)$/;"	f
_0.0	metalang.rkt	/^(define-syntax (_0.0 stx)$/;"	f
_0.5	metalang.rkt	/^(define-syntax (_0.5 stx)$/;"	f
_1.0	metalang.rkt	/^(define-syntax (_1.0 stx)$/;"	f
_2.0	metalang.rkt	/^(define-syntax (_2.0 stx)$/;"	f
_and	metalang.rkt	/^(define-syntax (_and stx)$/;"	f
_begin	metalang.rkt	/^(define-syntax (_begin stx)$/;"	f
_break	metalang.rkt	/^(define-syntax (_break stx)$/;"	f
_cos	metalang.rkt	/^(define-syntax (_cos stx)$/;"	f
_decl-real-func	metalang.rkt	/^(define-syntax (_decl-real-func stx)$/;"	f
_define-var	metalang.rkt	/^(define-syntax (_define-var stx)$/;"	f
_define-var-with-func-call	metalang.rkt	/^(define-syntax (_define-var-with-func-call stx)$/;"	f
_empty-statement	metalang.rkt	/^(define-syntax (_empty-statement stx)$/;"	f
_equal?	metalang.rkt	/^(define-syntax (_equal? stx)$/;"	f
_exact->inexact	metalang.rkt	/^(define-syntax (_exact->inexact stx)$/;"	f
_expt	metalang.rkt	/^(define-syntax (_expt stx)$/;"	f
_for	metalang.rkt	/^(define-syntax (_for stx)$/;"	f
_forever	metalang.rkt	/^(define-syntax (_forever stx)$/;"	f
_func-call	metalang.rkt	/^(define-syntax (_func-call stx)$/;"	f
_if	metalang.rkt	/^(define-syntax (_if stx)$/;"	f
_if-stm	metalang.rkt	/^(define-syntax (_if-stm stx)$/;"	f
_int*	metalang.rkt	/^(define-syntax (_int* stx)$/;"	f
_int+	metalang.rkt	/^(define-syntax (_int+ stx)$/;"	f
_int-	metalang.rkt	/^(define-syntax (_int- stx)$/;"	f
_int-neg	metalang.rkt	/^(define-syntax (_int-neg stx)$/;"	f
_int-vector-ref	metalang.rkt	/^(define-syntax (_int-vector-ref stx)$/;"	f
_int/	metalang.rkt	/^(define-syntax (_int\/ stx)$/;"	f
_int<	metalang.rkt	/^(define-syntax (_int< stx)$/;"	f
_int<=	metalang.rkt	/^(define-syntax (_int<= stx)$/;"	f
_int=	metalang.rkt	/^(define-syntax (_int= stx)$/;"	f
_int>	metalang.rkt	/^(define-syntax (_int> stx)$/;"	f
_int>=	metalang.rkt	/^(define-syntax (_int>= stx)$/;"	f
_let	metalang.rkt	/^(define-syntax (_let stx)$/;"	f
_let-int	metalang.rkt	/^(define-syntax (_let-int stx)$/;"	f
_local	metalang.rkt	/^(define-syntax (_local stx)$/;"	f
_not	metalang.rkt	/^(define-syntax (_not stx)$/;"	f
_nothing	metalang.rkt	/^(define-syntax (_nothing stx)$/;"	f
_or	metalang.rkt	/^(define-syntax (_or stx)$/;"	f
_pure-func-call	metalang.rkt	/^(define-syntax (_pure-func-call stx)$/;"	f
_rl*	metalang.rkt	/^(define-syntax (_rl* stx)$/;"	f
_rl+	metalang.rkt	/^(define-syntax (_rl+ stx)$/;"	f
_rl-	metalang.rkt	/^(define-syntax (_rl- stx)$/;"	f
_rl-neg	metalang.rkt	/^(define-syntax (_rl-neg stx)$/;"	f
_rl-vector	metalang.rkt	/^(define-syntax (_rl-vector stx)$/;"	f
_rl/	metalang.rkt	/^(define-syntax (_rl\/ stx)$/;"	f
_set!	metalang.rkt	/^(define-syntax (_set! stx)$/;"	f
_sin	metalang.rkt	/^(define-syntax (_sin stx)$/;"	f
_sqr	metalang.rkt	/^(define-syntax (_sqr stx)$/;"	f
_sqrt	metalang.rkt	/^(define-syntax (_sqrt stx)$/;"	f
_var-ref	metalang.rkt	/^(define-syntax (_var-ref stx)$/;"	f
_vector-ref	metalang.rkt	/^(define-syntax (_vector-ref stx)$/;"	f
_vector-set!	metalang.rkt	/^(define-syntax (_vector-set! stx)$/;"	f
add-argument!	environment.rkt	/^(define (add-argument! args name type)$/;"	f
add-lval-ders-to-rval!	backrun.rkt	/^(define (add-lval-ders-to-rval! der-table available-dx-table discard-table l-val-ref r-val-ref)$/;"	f
al_index_name_symbol	runtime-defs.rkt	/^(define al_index_name_symbol "al_index_name_symbol")$/;"	f
any-number?	environment.rkt	/^(define (any-number? n)$/;"	f
argument/c	environment.rkt	/^(define argument\/c (struct\/c argument symbol? type\/c))$/;"	f
assignation	backrun.rkt	/^(define-syntax (assignation stx)$/;"	f
assignation	semantics.rkt	/^(define-syntax (assignation stx)$/;"	f
atom-number	common-for-syntax.rkt	/^(define-for-syntax (atom-number stx)$/;"	f
atom-number	metalang.rkt	/^(define-for-syntax (atom-number stx)$/;"	f
backrun-ref/c	environment.rkt	/^(define backrun-ref\/c (list\/c (or\/c 'array-ref 'func-ref) var-symbol\/c integer?))$/;"	f
base-type/c	environment.rkt	/^(define base-type\/c (one-of\/c 'real 'int 'dual-l 'dual-r))$/;"	f
between	environment.rkt	/^(define\/contract$/;"	f
binary-op-cast	backrun.rkt	/^(define-for-syntax (binary-op-cast op1 op2 stx)$/;"	f
binary-op-cast	common-for-syntax.rkt	/^(define-for-syntax (binary-op-cast op1 op2 stx) (binary-op-cast-helper op1 op2 stx))$/;"	f
binary-op-cast	semantics.rkt	/^(define-for-syntax (binary-op-cast expr1 expr2 stx) (binary-op-cast-helper expr1 expr2 stx))$/;"	f
binary-op-cast-helper	common-for-syntax.rkt	/^(define-for-syntax (binary-op-cast-helper op1 op2 stx)$/;"	f
binding-type/c	environment.rkt	/^(define binding-type\/c (or\/c 'constant 'parameter 'variable 'function))$/;"	f
bool-expr	backrun.rkt	/^(define-syntax (bool-expr stx)$/;"	f
bool-expr	semantics.rkt	/^(define-syntax (bool-expr stx)$/;"	f
bool-factor	backrun.rkt	/^(define-syntax (bool-factor stx)$/;"	f
bool-factor	semantics.rkt	/^(define-syntax (bool-factor stx)$/;"	f
bool-term	backrun.rkt	/^(define-syntax (bool-term stx)$/;"	f
bool-term	semantics.rkt	/^(define-syntax (bool-term stx)$/;"	f
c*	combinators.rkt	/^(define (c* . x) (format "(~a)" (string-join (map (lambda (y) (format "~a" y)) x) " * ")))$/;"	f
c+	combinators.rkt	/^(define (c+ . x) (format "(~a)" (string-join (map (lambda (y) (format "~a" y)) x) " + ")))$/;"	f
c-	combinators.rkt	/^(define (c- x y) (format "(~a - ~a)" x y))$/;"	f
c-and	combinators.rkt	/^(define (c-and x y) (format "(~a && ~a)" x y))$/;"	f
c-array-ref	combinators.rkt	/^(define (c-array-ref name idx)$/;"	f
c-break	combinators.rkt	/^(define (c-break)$/;"	f
c-cos	combinators.rkt	/^(define (c-cos x) (format "cos(~a)" x))$/;"	f
c-cosl	combinators.rkt	/^(define (c-cosl x) (format "cosl(~a)" x))$/;"	f
c-declare-array	combinators.rkt	/^(define (c-declare-array type name size (modifier ""))$/;"	f
c-define	combinators.rkt	/^(define (c-define type name value (modifier ""))$/;"	f
c-define-array	combinators.rkt	/^(define (c-define-array type name size value (modifier ""))$/;"	f
c-exact->inexact	combinators.rkt	/^(define (c-exact->inexact value)$/;"	f
c-for	combinators.rkt	/^(define (c-for index start end body)$/;"	f
c-forever	combinators.rkt	/^(define (c-forever index start body)$/;"	f
c-func-call	combinators.rkt	/^(define (c-func-call func-name func-ret-symb args-list)$/;"	f
c-func-decl	combinators.rkt	/^(define (c-func-decl return-type name return-value args body)$/;"	f
c-if	combinators.rkt	/^(define (c-if pred true-body (false-body #f))$/;"	f
c-if-expr	combinators.rkt	/^(define (c-if-expr pred true-body false-body)$/;"	f
c-ignore-void	combinators.rkt	/^(define (c-ignore-void value)$/;"	f
c-indent	combinators.rkt	/^(define (c-indent value)$/;"	f
c-line-end	combinators.rkt	/^(define (c-line-end line)$/;"	f
c-make-array	combinators.rkt	/^(define (c-make-array values-list)$/;"	f
c-neg	combinators.rkt	/^(define (c-neg x) (format "-~a" x))$/;"	f
c-new-line	combinators.rkt	/^(define (c-new-line line)$/;"	f
c-not	combinators.rkt	/^(define (c-not x) (format "not~a" x))$/;"	f
c-or	combinators.rkt	/^(define (c-or x y) (format "(~a || ~a)" x y))$/;"	f
c-pow	combinators.rkt	/^(define (c-pow x y) (format "pow(~a, ~a)" x y))$/;"	f
c-powl	combinators.rkt	/^(define (c-powl x y) (format "powl(~a, ~a)" x y))$/;"	f
c-pure-func-call	combinators.rkt	/^(define (c-pure-func-call func-name args-list)$/;"	f
c-return	combinators.rkt	/^(define (c-return value)$/;"	f
c-set	combinators.rkt	/^(define (c-set symb value)$/;"	f
c-set-array	combinators.rkt	/^(define (c-set-array symb idx value)$/;"	f
c-sin	combinators.rkt	/^(define (c-sin x) (format "sin(~a)" x))$/;"	f
c-sinl	combinators.rkt	/^(define (c-sinl x) (format "sinl(~a)" x))$/;"	f
c-sqrt	combinators.rkt	/^(define (c-sqrt x) (format "sqrt(~a)" x))$/;"	f
c-sqrtl	combinators.rkt	/^(define (c-sqrtl x) (format "sqrtl(~a)" x))$/;"	f
c-with-brackets	combinators.rkt	/^(define (c-with-brackets body)$/;"	f
c/	combinators.rkt	/^(define (c\/ x y) (format "(~a \/ ~a)" x y))$/;"	f
c<	combinators.rkt	/^(define (c< x y) (format "(~a < ~a)" x y))$/;"	f
c<=	combinators.rkt	/^(define (c<= x y) (format "(~a <= ~a)" x y))$/;"	f
c==	combinators.rkt	/^(define (c== x y) (format "(~a == ~a)" x y))$/;"	f
c>	combinators.rkt	/^(define (c> x y) (format "(~a > ~a)" x y))$/;"	f
c>=	combinators.rkt	/^(define (c>= x y) (format "(~a >= ~a)" x y))$/;"	f
cast-func-args-list	semantics.rkt	/^(define-for-syntax (cast-func-args-list func-args-list)$/;"	f
cfg-target	target-config.rkt	/^(define\/contract$/;"	f
change-arg-type!	environment.rkt	/^(define (change-arg-type! args name new-type)$/;"	f
check-duplicate-argument-name	backrun.rkt	/^(define-for-syntax (check-duplicate-argument-name args funcname name stx-name)$/;"	f
check-duplicate-constant	backrun.rkt	/^(define-for-syntax (check-duplicate-constant name stx)$/;"	f
check-duplicate-constant	semantics.rkt	/^(define-for-syntax (check-duplicate-constant name stx)$/;"	f
check-duplicate-parameter	backrun.rkt	/^(define-for-syntax (check-duplicate-parameter name stx)$/;"	f
check-duplicate-parameter	semantics.rkt	/^(define-for-syntax (check-duplicate-parameter name stx)$/;"	f
check-duplicate-variable-name	backrun.rkt	/^(define-for-syntax (check-duplicate-variable-name name stx-name)$/;"	f
check-duplicate-variable-name	semantics.rkt	/^(define-for-syntax (check-duplicate-variable-name name stx-name)$/;"	f
check-proper-getter	backrun.rkt	/^(define-for-syntax (check-proper-getter idx-stx slice-colon expanded-range expanded-idx name-str stx)$/;"	f
check-real-arg-or-parameter-existence	backrun.rkt	/^(define-for-syntax (check-real-arg-or-parameter-existence name [get-range #f])$/;"	f
check-real-func-existence	backrun.rkt	/^(define-for-syntax (check-real-func-existence name [get-range #f])$/;"	f
check-real-var-existence	backrun.rkt	/^(define-for-syntax (check-real-var-existence name [get-range #f])$/;"	f
check-result	common-for-syntax.rkt	/^(define-for-syntax (check-result stx err-str func-res)$/;"	f
coerce-to-fixnum	backrun.rkt	/^(define-for-syntax (coerce-to-fixnum x)$/;"	f
coerce-to-list	backrun.rkt	/^(define (coerce-to-list any)$/;"	f
constant	backrun.rkt	/^(define-syntax (constant stx)$/;"	f
constant	semantics.rkt	/^(define-syntax (constant stx)$/;"	f
constants	environment.rkt	/^(define constants (make-hash))$/;"	f
current-arguments	backrun.rkt	/^(define-syntax-parameter current-arguments #f)$/;"	f
current-arguments/c	environment.rkt	/^(define current-arguments\/c (hash\/c symbol? argument\/c))$/;"	f
current-variables	backrun.rkt	/^(define-syntax-parameter current-variables #f)$/;"	f
current-variables/c	environment.rkt	/^(define current-variables\/c$/;"	f
debug	common-for-syntax.rkt	/^(define-for-syntax debug #f)$/;"	f
debug-backrun	backrun.rkt	/^(define debug-backrun #t)$/;"	f
debug-compile	semantics.rkt	/^(define-for-syntax debug-compile #f)$/;"	f
debug-runtime	runtime-defs.rkt	/^(define debug-runtime #f)$/;"	f
der-annot	backrun.rkt	/^(define-syntax (der-annot stx)$/;"	f
der-annot	semantics.rkt	/^(define-syntax (der-annot stx)$/;"	f
der-apply	backrun.rkt	/^(define-syntax (der-apply stx)$/;"	f
der-apply	semantics.rkt	/^(define-syntax (der-apply stx)$/;"	f
df-der-table/c	environment.rkt	/^(define df-der-table\/c (hash\/c dx-name\/c (list\/c (symbols 'dx-idxs) mutable-set\/c)))$/;"	f
df-name/c	environment.rkt	/^(define df-name\/c (list\/c var-symbol\/c integer?))$/;"	f
df-slice-idx-name-GLOBAL	backrun.rkt	/^(define-for-syntax df-slice-idx-name-GLOBAL 'df_slice_idx)$/;"	f
df-slice-idx-name-GLOBAL	semantics.rkt	/^(define-for-syntax df-slice-idx-name-GLOBAL 'df_slice_idx)$/;"	f
df_slice_idx	backrun.rkt	/^(define df_slice_idx #f)$/;"	f
df_slice_idx	runtime-defs.rkt	/^(define df_slice_idx 'bad_runtime_df_slice_idx)$/;"	f
discard	backrun.rkt	/^(define-syntax (discard stx)$/;"	f
discard	semantics.rkt	/^(define-syntax (discard stx)$/;"	f
dx-name-in-current-al	semantics.rkt	/^(define-syntax-parameter dx-name-in-current-al #f)$/;"	f
dx-name/c	environment.rkt	/^(define dx-name\/c string?)$/;"	f
dx-names-hash-set/c	environment.rkt	/^(define dx-names-hash-set\/c (hash\/c string? boolean?))$/;"	f
dx-names-set	backrun.rkt	/^(define-syntax-parameter dx-names-set #f)$/;"	f
dx-names-set/c	environment.rkt	/^(define dx-names-set\/c (hash\/c string? boolean?))$/;"	f
dx-slice-idx-name-GLOBAL	backrun.rkt	/^(define-for-syntax dx-slice-idx-name-GLOBAL 'dx_slice_idx)$/;"	f
dx-slice-idx-name-GLOBAL	semantics.rkt	/^(define-for-syntax dx-slice-idx-name-GLOBAL 'dx_slice_idx)$/;"	f
dx_slice_idx	backrun.rkt	/^(define dx_slice_idx #f)$/;"	f
dx_slice_idx	runtime-defs.rkt	/^(define dx_slice_idx 'bad_runtime_dx_slice_idx)$/;"	f
elem	lang/reader.rkt	/^(define (elem v lst)$/;"	f
element	backrun.rkt	/^(define-syntax (element stx)$/;"	f
element	semantics.rkt	/^(define-syntax (element stx)$/;"	f
expand-range	backrun.rkt	/^(define-for-syntax (expand-range rng-stx rng)$/;"	f
expand-type	type-utils.rkt	/^(define-for-syntax (expand-type type-stx)$/;"	f
expand-value-only	semantics.rkt	/^(define-syntax-parameter expand-value-only #f)$/;"	f
expanded-range	environment.rkt	/^(define\/contract$/;"	f
expr	backrun.rkt	/^(define-syntax (expr stx)$/;"	f
expr	semantics.rkt	/^(define-syntax (expr stx)$/;"	f
expr-body	backrun.rkt	/^(define-syntax (expr-body stx)$/;"	f
expr-body	semantics.rkt	/^(define-syntax (expr-body stx)$/;"	f
extract	common-for-syntax.rkt	/^(define-for-syntax (extract stx)$/;"	f
factor	backrun.rkt	/^(define-syntax (factor stx)$/;"	f
factor	semantics.rkt	/^(define-syntax (factor stx)$/;"	f
fmap	common-for-syntax.rkt	/^(define-for-syntax (fmap f maybe-false)$/;"	f
for-expr	backrun.rkt	/^(define-syntax (for-expr stx)$/;"	f
for-expr	semantics.rkt	/^(define-syntax (for-expr stx)$/;"	f
func	backrun.rkt	/^(define-syntax (func stx)$/;"	f
func	semantics.rkt	/^(define-syntax (func stx)$/;"	f
func-body	backrun.rkt	/^(define-syntax (func-body stx)$/;"	f
func-body	semantics.rkt	/^(define-syntax (func-body stx)$/;"	f
func-call	backrun.rkt	/^(define-syntax (func-call stx)$/;"	f
func-call	semantics.rkt	/^(define-syntax (func-call stx)$/;"	f
func-call-ht	semantics.rkt	/^(define-syntax-parameter func-call-ht 'func-call-ht-not-set)$/;"	f
func-call-ht/c	environment.rkt	/^(define func-call-ht\/c (hash\/c symbol? func-call-info\/c))$/;"	f
func-call-info/c	environment.rkt	/^(define func-call-info\/c$/;"	f
func-context	semantics.rkt	/^(define-syntax-parameter func-context #f)$/;"	f
func-context/c	environment.rkt	/^(define func-context\/c$/;"	f
func-info/c	environment.rkt	/^(define func-info\/c $/;"	f
func-slice-idx-name-GLOBAL	backrun.rkt	/^(define-for-syntax func-slice-idx-name-GLOBAL 'func_slice_idx)$/;"	f
func-slice-idx-name-GLOBAL	semantics.rkt	/^(define-for-syntax func-slice-idx-name-GLOBAL 'func_slice_idx)$/;"	f
func_slice_idx	backrun.rkt	/^(define func_slice_idx #f)$/;"	f
func_slice_idx	runtime-defs.rkt	/^(define func_slice_idx 'bad_runtime_func_slice_idx)$/;"	f
funcs-info-GLOBAL	backrun.rkt	/^(define-for-syntax funcs-info-GLOBAL (make-hash))$/;"	f
funcs-info-GLOBAL	semantics.rkt	/^(define-for-syntax funcs-info-GLOBAL #f)$/;"	f
funcs-info/c	environment.rkt	/^(define funcs-info\/c (hash\/c var-symbol\/c func-info\/c))$/;"	f
function-name	backrun.rkt	/^(define-syntax-parameter function-name #f)$/;"	f
function-return-type	backrun.rkt	/^(define-syntax-parameter function-return-type  #f)$/;"	f
function-return-value	backrun.rkt	/^(define-syntax-parameter function-return-value #f)$/;"	f
functions-data-ht-GLOBAL	semantics.rkt	/^(define-for-syntax functions-data-ht-GLOBAL #f)$/;"	f
functions-symbols/c	environment.rkt	/^(define functions-symbols\/c (hash\/c string? symbol?))$/;"	f
fxvec->vec	common-for-syntax.rkt	/^(define (fxvec->vec fxvec)$/;"	f
fxvec->vec	common-for-syntax.rkt	/^(define-for-syntax (fxvec->vec fxvec)$/;"	f
fxvector->vector	common-for-syntax.rkt	/^(define-for-syntax (fxvector->vector fxvec)$/;"	f
get-arg-type	semantics.rkt	/^(define-for-syntax (get-arg-type d-name)$/;"	f
get-arg-type-helper	common-for-syntax.rkt	/^(define-for-syntax (get-arg-type-helper d-name current-arguments)$/;"	f
get-array-type	common-for-syntax.rkt	/^(define-for-syntax (get-array-type type)$/;"	f
get-derivative	backrun.rkt	/^(define-syntax (get-derivative stx)$/;"	f
get-derivative	semantics.rkt	/^(define-syntax (get-derivative stx)$/;"	f
get-derivative-stx	common-for-syntax.rkt	/^(define-for-syntax (get-derivative-stx dual-b-expanded-stx)$/;"	f
get-expanded-slice-index-end	backrun.rkt	/^(define-for-syntax (get-expanded-slice-index-end stx index-end array-range-stx)$/;"	f
get-expanded-slice-index-start	backrun.rkt	/^(define-for-syntax (get-expanded-slice-index-start index-start)$/;"	f
get-name-mode	semantics.rkt	/^(define-syntax-parameter get-name-mode #f)$/;"	f
get-real-arg-or-parameter-type	semantics.rkt	/^(define-for-syntax (get-real-arg-or-parameter-type name)$/;"	f
get-real-arg-or-var-type	semantics.rkt	/^(define-for-syntax (get-real-arg-or-var-type d-name)$/;"	f
get-slice-range	common-for-syntax.rkt	/^(define-for-syntax (get-slice-range type)$/;"	f
get-slice-start-and-range	common-for-syntax.rkt	/^(define-for-syntax (get-slice-start-and-range stx slice-colon index-start index-end array-range)$/;"	f
get-slice-type	common-for-syntax.rkt	/^(define-for-syntax (get-slice-type type)$/;"	f
get-source-name	target-config.rkt	/^(define (get-source-name)$/;"	f
get-value	backrun.rkt	/^(define-syntax (get-value stx)$/;"	f
get-value	semantics.rkt	/^(define-syntax (get-value stx)$/;"	f
get-value-stx	common-for-syntax.rkt	/^(define-for-syntax (get-value-stx dual-b-expanded-stx)$/;"	f
grouped-keys-table/c	environment.rkt	/^(define grouped-keys-table\/c (hash\/c var-symbol\/c (listof integer?)))$/;"	f
has-dual	common-for-syntax.rkt	/^(define-for-syntax (has-dual stx)$/;"	f
hash->string	environment.rkt	/^(define (hash->string ht)$/;"	f
if-expr	backrun.rkt	/^(define-syntax (if-expr stx)$/;"	f
if-expr	semantics.rkt	/^(define-syntax (if-expr stx)$/;"	f
indent-step	combinators.rkt	/^(define indent-step 2)$/;"	f
instantiate	type-utils.rkt	/^(define-for-syntax (instantiate type-stx)$/;"	f
instantiate-dual-var	common-for-syntax.rkt	/^(define-for-syntax (instantiate-dual-var df-type dx-mapped-size stx)$/;"	f
is-array-ref?	common-for-syntax.rkt	/^(define (is-array-ref? ref) (equal? (car ref) 'array-ref))$/;"	f
is-array-type?	common-for-syntax.rkt	/^(define-for-syntax (is-array-type? type)$/;"	f
is-basic-ref?	common-for-syntax.rkt	/^(define (is-basic-ref? ref) (equal? (car ref) 'basic-ref))$/;"	f
is-dual	common-for-syntax.rkt	/^(define-for-syntax (is-dual stx)$/;"	f
is-func?	backrun.rkt	/^(define-for-syntax (is-func? stx)$/;"	f
is-int	common-for-syntax.rkt	/^(define-for-syntax (is-int stx)$/;"	f
is-int-index	backrun.rkt	/^(define-for-syntax (is-int-index stx)$/;"	f
is-real	common-for-syntax.rkt	/^(define-for-syntax (is-real stx)$/;"	f
is-slice-of-type	common-for-syntax.rkt	/^(define-for-syntax (is-slice-of-type basic-type type)$/;"	f
is-slice?	common-for-syntax.rkt	/^(define-for-syntax (is-slice? type)$/;"	f
is-type	common-for-syntax.rkt	/^(define-for-syntax (is-type stx type)$/;"	f
is-type_	common-for-syntax.rkt	/^(define-for-syntax (is-type_ type stx)$/;"	f
lambda	environment.rkt	/^(define\/contract$/;"	f
landau-type	common-for-syntax.rkt	/^(define-for-syntax (landau-type base-type (slice-range #f))$/;"	f
landau-type/c	environment.rkt	/^(define landau-type\/c (list\/c base-type\/c (or\/c (list\/c integer?) (list\/c))))$/;"	f
lang/c	target-config.rkt	/^(define lang\/c (one-of\/c 'racket 'ansi-c))$/;"	f
lexer-src-pos-with-tokens	lexer.rkt	/^(define-syntax (lexer-src-pos-with-tokens stx)$/;"	f
list->rl-vector	common-for-syntax.rkt	/^(define-for-syntax (list->rl-vector value-list)$/;"	f
log-debug	backrun.rkt	/^(define (log-debug msg)$/;"	f
log-debug	runtime-defs.rkt	/^(define (log-debug msg)$/;"	f
log-debug	semantics.rkt	/^(define-for-syntax (log-debug msg [force-log #f])$/;"	f
loop	runtime-defs.rkt	/^(define (loop i end body)$/;"	f
loop-forever	runtime-defs.rkt	/^(define (loop-forever i body)$/;"	f
make-der-decl-list!	semantics.rkt	/^(define-for-syntax (make-der-decl-list! args stx)$/;"	f
make-derivative-getter-func	semantics.rkt	/^(define-for-syntax (make-derivative-getter-func stx)$/;"	f
make-derivative-getter-func/array	semantics.rkt	/^(define-for-syntax (make-derivative-getter-func\/array stx)$/;"	f
make-dual-type	common-for-syntax.rkt	/^(define-for-syntax (make-dual-type parsed-type dual-type)$/;"	f
make-mappings-decl-list!	semantics.rkt	/^(define-for-syntax (make-mappings-decl-list! dx-name-str grouped-keys-table stx)$/;"	f
mapped_idx	runtime-defs.rkt	/^(define mapped_idx 'mapped_idx_not_set)$/;"	f
mapping-sizes/c	environment.rkt	/^(define mapping-sizes\/c (struct\/c mapping-sizes integer? integer?))$/;"	f
mappings_full_idx_symbol	runtime-defs.rkt	/^(define mappings_full_idx_symbol 'mappings_full_idx_not_set)$/;"	f
mutable-set/c	environment.rkt	/^(define (mutable-set\/c a) any\/c)$/;"	f
my-read	lang/reader.rkt	/^(define (my-read in)$/;"	f
my-read-syntax	lang/reader.rkt	/^(define (my-read-syntax src ip)$/;"	f
n	environment.rkt	/^(define\/contract$/;"	f
need-derivatives?	semantics.rkt	/^(define-for-syntax (need-derivatives? name-str)$/;"	f
need-only-value-set/c	environment.rkt	/^(define need-only-value-set\/c (mutable-set\/c var-symbol\/c))$/;"	f
new-variables-nesting	environment.rkt	/^(define (new-variables-nesting vars)$/;"	f
normilize-rl	common-for-syntax.rkt	/^(define-for-syntax (normilize-rl rl)$/;"	f
not-void?	common-for-syntax.rkt	/^(define-for-syntax (not-void? it) (not (equal? (void) it)))$/;"	f
not-void?	runtime-defs.rkt	/^(define (not-void? it) (not (equal? (void) it)))$/;"	f
number	backrun.rkt	/^(define-syntax (number stx)$/;"	f
number	semantics.rkt	/^(define-syntax (number stx)$/;"	f
offset	combinators.rkt	/^(define offset (make-parameter 0))$/;"	f
offset-string	combinators.rkt	/^(define (offset-string level) (make-string (fx* level indent-step) #\\ ))$/;"	f
override-with-command-line	target-config.rkt	/^(define\/contract (override-with-command-line cfg-target)$/;"	f
parameter	backrun.rkt	/^(define-syntax (parameter stx)$/;"	f
parameter	semantics.rkt	/^(define-syntax (parameter stx)$/;"	f
parameters	environment.rkt	/^(define parameters (make-hash))$/;"	f
parse-target-cfg	target-config.rkt	/^(define (parse-target-cfg inp-path)$/;"	f
parse-type	environment.rkt	/^(define (parse-type t)$/;"	f
parse-type-to-syntax	environment.rkt	/^(define (parse-type-to-syntax t)$/;"	f
path-only_	target-config.rkt	/^(define (path-only_ path)$/;"	f
prepand-headers	combinators.rkt	/^(define (prepand-headers src-str)$/;"	f
primary	backrun.rkt	/^(define-syntax (primary stx)$/;"	f
primary	semantics.rkt	/^(define-syntax (primary stx)$/;"	f
print	backrun.rkt	/^(define-syntax (print stx)$/;"	f
print	semantics.rkt	/^(define-syntax (print stx)$/;"	f
program	backrun.rkt	/^(define-syntax (program stx)$/;"	f
program	semantics.rkt	/^(define-syntax (program stx)$/;"	f
prohibition-list/c	environment.rkt	/^(define prohibition-list\/c (listof binding-type\/c))$/;"	f
range-casting-check	backrun.rkt	/^(define-for-syntax (range-casting-check stx r-value-type lvalue-outer-prod-range)$/;"	f
range-check	backrun.rkt	/^(define-for-syntax (range-check stx idx range)$/;"	f
range-check-stx	backrun.rkt	/^(define-for-syntax (range-check-stx stx idx range)$/;"	f
real-vars-table	backrun.rkt	/^(define-syntax-parameter real-vars-table #f)$/;"	f
resolve-path	target-config.rkt	/^(define (resolve-path relative-path)$/;"	f
rl*	common-for-syntax.rkt	/^(define-for-syntax rl*$/;"	f
rl+	common-for-syntax.rkt	/^(define-for-syntax rl+$/;"	f
rl-	common-for-syntax.rkt	/^(define-for-syntax rl-$/;"	f
rl-cos	common-for-syntax.rkt	/^(define-for-syntax rl-cos$/;"	f
rl-expt	common-for-syntax.rkt	/^(define-for-syntax rl-expt$/;"	f
rl-neg	common-for-syntax.rkt	/^(define-for-syntax (rl-neg n)$/;"	f
rl-sin	common-for-syntax.rkt	/^(define-for-syntax rl-sin$/;"	f
rl-sqr	common-for-syntax.rkt	/^(define-for-syntax (rl-sqr x)$/;"	f
rl-sqrt	common-for-syntax.rkt	/^(define-for-syntax rl-sqrt$/;"	f
rl-vector-ref	common-for-syntax.rkt	/^(define-for-syntax rl-vector-ref$/;"	f
rl/	common-for-syntax.rkt	/^(define-for-syntax rl\/$/;"	f
search-argument	environment.rkt	/^(define (search-argument name args)$/;"	f
search-variable	environment.rkt	/^(define (search-variable name vars)$/;"	f
set-need-only-value-set!	common-for-syntax.rkt	/^(define-for-syntax (set-need-only-value-set! grouped-keys-table der-table need-only-value-set)$/;"	f
single-term	backrun.rkt	/^(define-syntax (single-term stx)$/;"	f
single-term	semantics.rkt	/^(define-syntax (single-term stx)$/;"	f
slice-helper	backrun.rkt	/^(define-for-syntax (slice-helper stx dx-index-start dx-index-end expanded-range-dx)$/;"	f
slice-idx-name-GLOBAL	backrun.rkt	/^(define-for-syntax slice-idx-name-GLOBAL 'slice_idx)$/;"	f
slice-idx-name-GLOBAL	semantics.rkt	/^(define-for-syntax slice-idx-name-GLOBAL 'slice_idx)$/;"	f
slice_idx	backrun.rkt	/^(define slice_idx #f)$/;"	f
slice_idx	runtime-defs.rkt	/^(define slice_idx 'bad-runtime)$/;"	f
splice-nested	backrun.rkt	/^(define (splice-nested lst)$/;"	f
syntax->string	environment.rkt	/^(define (syntax->string stx)$/;"	f
syntax->string	metalang.rkt	/^(define-for-syntax (syntax->string stx)$/;"	f
syntax/parse	lexer.rkt	/^(define-lex-abbrevs$/;"	f
target/c	target-config.rkt	/^(define target\/c (struct\/c target $/;"	f
term	backrun.rkt	/^(define-syntax (term stx)$/;"	f
term	semantics.rkt	/^(define-syntax (term stx)$/;"	f
throw-if-bundle-mistype	backrun.rkt	/^(define (throw-if-bundle-mistype bundl-1 bundl-2)$/;"	f
throw-if-not-int	environment.rkt	/^(define (throw-if-not-int stx [annotation ""])$/;"	f
throw-if-not-type	environment.rkt	/^(define (throw-if-not-type expected-type stx [annotation ""])$/;"	f
throw-if-r-value-is-slice	backrun.rkt	/^(define-for-syntax (throw-if-r-value-is-slice stx r-value-stx)$/;"	f
to-c-decl	combinators.rkt	/^(define (to-c-decl landau-parsed-type name-str [value #'#f])$/;"	f
to-c-der-decl	combinators.rkt	/^(define (to-c-der-decl df-type dx-size name-str)  $/;"	f
to-c-func-param	combinators.rkt	/^(define (to-c-func-param landau-parsed-type name-str target)$/;"	f
to-string	combinators.rkt	/^(define (to-string x)$/;"	f
tokenize	lexer.rkt	/^(define (tokenize ip)$/;"	f
type-base	type-utils.rkt	/^(define-for-syntax (type-base type-stx)$/;"	f
type-range	type-utils.rkt	/^(define-for-syntax (type-range type-stx)$/;"	f
type/c	environment.rkt	/^(define type\/c any\/c)$/;"	f
typecheck-mode	semantics.rkt	/^(define-syntax-parameter typecheck-mode #f)$/;"	f
unknown	environment.rkt	/^(define\/contract$/;"	f
var-decl	backrun.rkt	/^(define-syntax (var-decl stx)$/;"	f
var-decl	semantics.rkt	/^(define-syntax (var-decl stx)$/;"	f
var-symbol/c	environment.rkt	/^(define var-symbol\/c$/;"	f
variable/c	environment.rkt	/^(define variable\/c (struct\/c variable $/;"	f
vec->fxvec	common-for-syntax.rkt	/^(define (vec->fxvec vec)$/;"	f
vec->fxvec	common-for-syntax.rkt	/^(define-for-syntax (vec->fxvec vec)$/;"	f
vector->carray	common-for-syntax.rkt	/^(define-for-syntax (vector->carray vec)$/;"	f
with-syntax-property	common-for-syntax.rkt	/^(define-for-syntax (with-syntax-property property-name property-value stx)$/;"	f
write-source	semantics.rkt	/^(define-for-syntax (write-source stx src-synt)$/;"	f
xor	common-for-syntax.rkt	/^(define-for-syntax (xor e1 e2)$/;"	f
