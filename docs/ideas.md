0. Надо будет пройтись профайлером по всей компиляции и найти узкое место

1. array1[:] = array2[:] при транспиляции в Си - обычное копирование из rhs в lhs через цикл. Можно реализовать то же самое с помощью какого-нибудь memset

2. **Инструкция print не поддержана для anci-c бэкенда. Круто было бы это исправить, заодно разобравшись в проекте.**

3. Похоже, landau-типы тупо захардкожены. Нужно вынести их декларации в отдельное место и просто ссылаться на них при надобности.

4. Идея не столько по Landau, сколько по Racket. Нужно добавить адекватную поддержку этого языка в VSC!

5. Добавить в язык СТРОКИ!

6. **Массивы интов все еще не поддержаны в языке. ДОБАВЬ!!**

7. СОЗДАЙ БАЗУ ЗНАНИЙ

8. Исправь вот это:
   ```;; FIXME Do not fail array get-value without index of slice. Array can be passed to a function: f(arr)```
   в backrun.rkt:407

9. В common-for-syntax.rkt::binary-op-cast-helper происходит комбинаторный взрыв при добавлении новых типов.

10. БАГ???? ПРОСТО x имеет тип 'real, а не '(real (list size)). Надо понять, плохо ли это. Видимо, проблема похожа на проблему в пункте 8.

11. Баг или фича? x[1:5] парсится в ```(#%app c-array-ref (quote "x12") (#%app c+ (quote 1) (quote "slice_idx")))```

12. Скорее всего, баг, относящийся к пункту 11. 'landau-type слайса - (real (range-placeholder)). Где индексы? Как из этого получать нужную инфу?

13. Добавить функцию debug, которая при установке флага DEBUG будет выводить аргументы на экран c выводом имен аргументов:
    (debug get-value get-something) => "get-value: <value1>, get-something: <value2>\n"






## План и идеи по работе над print в ansi-c

В racket-backend print выводит такую инфу: ```(format "~a: ~a type: ~a, value: ~a" line str type val)```
val - pattern variable, поэтому сначала была идея считать val на этапе компиляции и подставлять значение в printf.
Но лучше сразу закладываться под динамические массивы и циклы, поэтому нужно передавать в printf переменную, которую мы принтуем.

Есть подходящая функция в semantics.rkt::101!

-1. Возможно, придется обработку print перенести в backrun.rkt! Там есть подходящие функции для выдергивания типов

0. Тебе нужно изучить то, как выражениям присваиваются типы. Тогда станет полегче.
Окей... Принтоваться у нас может и обычный expr. У него нет конкретного имени. Но тайпчекер гарантирует (я на это надеюсь) нам,
что у результата expr будет вполне определенный тип. Надо научиться этот тип доставать, чтобы понять, какой printf подставлять/вызывать.
С другой стороны, мы можем понадеяться на сам язык Си. То есть мы можем в program сгенерить кучу перегруженных функций с именем print
по разным именам и типам аргументов. Так проблема решится автоматически. Но мне не очень хочется забивать на разбирательство в том,
как в Landau работают syntax-property и подобные штуки, которые несут в себе информацию о синтаксическом объекте. НАДО РАЗБИРАТЬСЯ!
**Подумай вот над чем:** что будет быстрее - всегда вызывать одну функцию print или вставлять, где можно, printf? Есть ли разница, если print будет static inline?

1. Нужно разобраться с тем, как работает транспиляция в С, т.е. где текст пишется в нужный файл.

2. Extfloat тоже нужно поддержать.

3. У print есть странная продукция: ```print IDENTIFIER (expr | get-derivative)```. Надо разобраться, что это.

4. Если мы принтуем int или real, то скомпилить это надо в вызов printf. Иначе - вызывать заранее созданную функцию.
   Т.е. ```if (type == int) { insert("printf("%d\n", value);") }``` и т.д.

5. Не забудь поддержать слайсы!

Еще есть проблема в грамматике. Правило ```print : "print" IDENTIFIER (expr | get-derivative) | "print" (expr | get-derivative)```
строит плохое дерево разбора для ```print f + 4*real_var```:
```f (expr (term (term (factor (primary (unop "+") (primary (element (number 4)))))) "*" (factor (primary (element (get-value real_var))))))```,
причем local-expand-memo с этим деревом выдает плохое (#%app c* (#%app to-string (quote 4.0)) (#%app to-string (quote "real_var16")))

Итог: на данном этапе не получится реализовать правильное поведение выражения ```print x```, где x - массив.
Возможно только ```print x[:]```. Проблема в том, что тип переменных в таблицах а-ля func-context-.current-variables, func-context-.current-arguments и т.д.
хранится нормальный (т.е. ```'(type (list arr-size))```), но в синтаксических объектах передается только тип type или type-slice.
Надо понять, почему так и исправить, если возможно.

Полезные штуки - getter.index? ...?

### ИДЕЯ!!!! штуки с (#%app c-array-ref ...) - это уже распаршенный в сишные макросы (metalang.rkt) список
По всей видимости, в функцию с обработкой c-array-ref передается случай со слайсами, что тупо. Надо исправлять баг


## ПЛАН:

1. Сделать print со всеми текущими ограничениями.
2. Заняться нормальной проверкой типов, а то происходящее сейчас - тихий ужас.
3. (придумать)